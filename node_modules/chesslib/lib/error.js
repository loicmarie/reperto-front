"use strict";
Object.defineProperties(exports, {
  ChessError: {get: function() {
      return ChessError;
    }},
  MobilityError: {get: function() {
      return MobilityError;
    }},
  CheckError: {get: function() {
      return CheckError;
    }},
  PromotionError: {get: function() {
      return PromotionError;
    }},
  ResultError: {get: function() {
      return ResultError;
    }},
  AmbiguityError: {get: function() {
      return AmbiguityError;
    }},
  __esModule: {value: true}
});
var ChessError = function ChessError(message, position) {
  Error.call(this);
  this.name = this.constructor.name;
  this.message = message != null ? message : this.name;
  this.position = position;
};
($traceurRuntime.createClass)(ChessError, {}, {}, Error);
var MobilityError = function MobilityError() {
  $traceurRuntime.defaultSuperCall(this, $MobilityError.prototype, arguments);
};
var $MobilityError = MobilityError;
($traceurRuntime.createClass)(MobilityError, {}, {}, ChessError);
var CheckError = function CheckError() {
  $traceurRuntime.defaultSuperCall(this, $CheckError.prototype, arguments);
};
var $CheckError = CheckError;
($traceurRuntime.createClass)(CheckError, {}, {}, ChessError);
var PromotionError = function PromotionError() {
  $traceurRuntime.defaultSuperCall(this, $PromotionError.prototype, arguments);
};
var $PromotionError = PromotionError;
($traceurRuntime.createClass)(PromotionError, {}, {}, ChessError);
var ResultError = function ResultError() {
  $traceurRuntime.defaultSuperCall(this, $ResultError.prototype, arguments);
};
var $ResultError = ResultError;
($traceurRuntime.createClass)(ResultError, {}, {}, ChessError);
var AmbiguityError = function AmbiguityError(rejection, candidates) {
  $traceurRuntime.superCall(this, $AmbiguityError.prototype, "constructor", [("Ambiguous notation: " + rejection)]);
  this.rejection = rejection;
  this.candidates = candidates;
};
var $AmbiguityError = AmbiguityError;
($traceurRuntime.createClass)(AmbiguityError, {}, {}, ChessError);

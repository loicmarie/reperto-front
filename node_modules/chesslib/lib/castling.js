"use strict";
Object.defineProperties(exports, {
  Castling: {get: function() {
      return Castling;
    }},
  __esModule: {value: true}
});
var Point = require('./point').Point;
var $__1 = require('./brands'),
    KING = $__1.KING,
    ROOK = $__1.ROOK,
    QUEENSIDE = $__1.QUEENSIDE,
    KINGSIDE = $__1.KINGSIDE,
    WHITE = $__1.WHITE,
    BLACK = $__1.BLACK;
var CheckError = require('./error').CheckError;
var oppositeColor = require('./util').oppositeColor;
var Castling = function Castling($__8) {
  var $__10,
      $__11;
  var $__9 = $traceurRuntime.assertObject($__8),
      fenEncoding = ($__10 = $__9.fenEncoding) === void 0 ? '' : $__10,
      modes = ($__11 = $__9.modes) === void 0 ? parseCastlingModes(fenEncoding) : $__11,
      rook = $__9.rook,
      square = $__9.square;
  this.modes = modes;
  this.rook = rook;
  this.square = square;
};
var $Castling = Castling;
($traceurRuntime.createClass)(Castling, {
  isLegal: function(color, side) {
    return this.modes[$traceurRuntime.toProperty(color)][$traceurRuntime.toProperty(side)];
  },
  toString: function() {
    var modes = this.modes;
    return [modes[$traceurRuntime.toProperty(WHITE)][$traceurRuntime.toProperty(KINGSIDE)] ? 'K' : '', modes[$traceurRuntime.toProperty(WHITE)][$traceurRuntime.toProperty(QUEENSIDE)] ? 'Q' : '', modes[$traceurRuntime.toProperty(BLACK)][$traceurRuntime.toProperty(KINGSIDE)] ? 'k' : '', modes[$traceurRuntime.toProperty(BLACK)][$traceurRuntime.toProperty(QUEENSIDE)] ? 'q' : ''].join('') || '-';
  }
}, {
  analyze: function(position, piece, coords) {
    var $__8 = $traceurRuntime.assertObject(piece),
        brand = $__8.brand,
        color = $__8.color;
    var castling = $traceurRuntime.assertObject(position).castling;
    if (brand !== KING) {
      return new $Castling({modes: castling.modes});
    }
    var side = $Castling.side(position, piece, coords);
    var modes = blankModes();
    var opponent = oppositeColor(position.activeColor);
    $traceurRuntime.setProperty(modes, opponent, position.castling.modes[$traceurRuntime.toProperty(opponent)]);
    if (side == null || !castling.isLegal(color, side)) {
      return new $Castling({modes: modes});
    }
    if (!isValid(position, color, side)) {
      throw new CheckError();
    }
    return new $Castling({
      rook: $Castling.rook(position, color, side),
      square: position.pieceCoords(piece).sum($Castling.rookOffset(color, side)),
      modes: modes
    });
  },
  side: function(position, king, coords) {
    if (king.brand !== KING) {
      return null;
    }
    for (var $__6 = [KINGSIDE, QUEENSIDE][$traceurRuntime.toProperty(Symbol.iterator)](),
        $__7; !($__7 = $__6.next()).done; ) {
      var side = $__7.value;
      {
        if ($Castling.isCastlingMove(position, king, side, coords)) {
          return side;
        }
      }
    }
    return null;
  },
  rook: function(position, color, side) {
    var kingX = $traceurRuntime.assertObject(position.pieceCoords(position.piece({
      brand: KING,
      color: color
    }))).x;
    for (var $__6 = position.pieces({
      brand: ROOK,
      color: color
    })[$traceurRuntime.toProperty(Symbol.iterator)](),
        $__7; !($__7 = $__6.next()).done; ) {
      var rook = $__7.value;
      {
        try {
          throw undefined;
        } catch (rookX) {
          {
            rookX = $traceurRuntime.assertObject(position.pieceCoords(rook)).x;
            if (color === WHITE ? ((rookX > kingX && side === KINGSIDE) || (rookX < kingX && side === QUEENSIDE)) : ((rookX > kingX && side === QUEENSIDE) || (rookX < kingX && side === KINGSIDE))) {
              return rook;
            }
          }
        }
      }
    }
  },
  isCastlingMove: function(position, king, side, coords) {
    return (position.pieceCoords(king).sum($Castling.kingOffset(king.color, side)).equal(coords));
  },
  kingOffset: function(color, side) {
    return new Point(xOffset(color, side, 2), 0);
  },
  rookOffset: function(color, side) {
    return new Point(xOffset(color, side, -1), 0).sum($Castling.kingOffset(color, side));
  }
});
var blankMode = (function() {
  var $__5;
  return (($__5 = {}, Object.defineProperty($__5, KINGSIDE, {
    value: false,
    configurable: true,
    enumerable: true,
    writable: true
  }), Object.defineProperty($__5, QUEENSIDE, {
    value: false,
    configurable: true,
    enumerable: true,
    writable: true
  }), $__5));
});
var blankModes = (function() {
  var $__5;
  return (($__5 = {}, Object.defineProperty($__5, WHITE, {
    value: blankMode(),
    configurable: true,
    enumerable: true,
    writable: true
  }), Object.defineProperty($__5, BLACK, {
    value: blankMode(),
    configurable: true,
    enumerable: true,
    writable: true
  }), $__5));
});
var sides = {
  'q': QUEENSIDE,
  'k': KINGSIDE
};
function parseCastlingModes(castling) {
  var modes = blankModes();
  String(castling || '').split('').forEach((function(mode) {
    var modeLower = mode.toLowerCase();
    var color = modeLower === mode ? BLACK : WHITE;
    $traceurRuntime.setProperty(modes[$traceurRuntime.toProperty(color)], sides[$traceurRuntime.toProperty(modeLower)], true);
  }));
  return modes;
}
function xOffset(color, side) {
  var m = arguments[2] !== (void 0) ? arguments[2] : 1;
  if (color === WHITE) {
    if (side === KINGSIDE) {
      return m;
    } else if (side === QUEENSIDE) {
      return -m;
    }
  } else if (color === BLACK) {
    if (side === KINGSIDE) {
      return -m;
    } else if (side === QUEENSIDE) {
      return m;
    }
  }
}
function isValid(position, color, side) {
  var loc = position.pieceCoords(position.piece({
    brand: KING,
    color: color
  }));
  for (var $__6 = loc.to(loc.sum(Castling.kingOffset(color, side)))[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__7; !($__7 = $__6.next()).done; ) {
    var pt = $__7.value;
    {
      if (position.isCheck(color, pt)) {
        return false;
      }
    }
  }
  return true;
}

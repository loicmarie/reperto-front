"use strict";
Object.defineProperties(exports, {
  Mobility: {get: function() {
      return Mobility;
    }},
  quadrants: {get: function() {
      return quadrants;
    }},
  __esModule: {value: true}
});
var PAWN = require('./brands').PAWN;
var Point = require('./point').Point;
var $__2 = require('./util'),
    squareName = $__2.squareName,
    squareCoords = $__2.squareCoords;
var Mobility = function Mobility(m, n) {
  this.m = m;
  this.n = n;
};
($traceurRuntime.createClass)(Mobility, {
  test: function(position, src, dest) {
    for (var $__4 = this.adjacentPoints(position, src)[$traceurRuntime.toProperty(Symbol.iterator)](),
        $__5; !($__5 = $__4.next()).done; ) {
      var adj = $__5.value;
      {
        if (dest.equal(adj)) {
          return true;
        }
      }
    }
    return false;
  },
  adjacentPoints: $traceurRuntime.initGeneratorFunction(function $__8(position, coords) {
    return $traceurRuntime.createGeneratorInstance(function($ctx) {
      while (true)
        switch ($ctx.state) {
          case 0:
            throw new Error("subclass must override Mobility#adjacentPoints");
            $ctx.state = -2;
            break;
          default:
            return $ctx.end();
        }
    }, $__8, this);
  })
}, {isLegal: function($__6) {
    var $__7 = $traceurRuntime.assertObject($__6),
        position = $__7.position,
        piece = $__7.piece,
        target = $__7.target,
        capturePiece = $__7.capturePiece;
    if (position.activeColor !== piece.color) {
      return false;
    }
    if (capturePiece != null) {
      if (piece.color === capturePiece.color) {
        return false;
      }
      return legally('canCapture', position, piece, target);
    }
    return legally('canMove', position, piece, target);
  }});
var quadrants = [new Point(1, 1), new Point(1, -1), new Point(-1, 1), new Point(-1, -1)];
function legally(method, position, piece, target) {
  return piece[$traceurRuntime.toProperty(method)](position, position.pieceCoords(piece), target);
}

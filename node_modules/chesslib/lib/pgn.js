"use strict";
Object.defineProperties(exports, {
  PGN: {get: function() {
      return PGN;
    }},
  __esModule: {value: true}
});
var FEN = require('./fen').FEN;
var Game = require('./game').Game;
var ChessError = require('./error').ChessError;
var $__3 = require('./util'),
    partition = $__3.partition,
    last = $__3.last;
var TOKEN_TAG = 'tag';
var TOKEN_RESULT = 'result';
var TOKEN_MOVE_NUMBER_NOTATION = 'move number';
var TOKEN_PLY_NOTATION = 'ply';
var TOKEN_ANNOTATION_NOTATION = 'annotation';
var PGN = {
  parse: function(pgnStr) {
    return pgnStr.split(/\r\n\r\n\r\n|\n\n\n/).map(parseGame);
  },
  stringify: function(game) {}
};
function parseGame(gameStr) {
  var tokens = tokenizePGN((" " + gameStr.split(/[\n\r\r\t]+/g).join(' ') + " "));
  var game = new Game();
  try {
    tokens.forEach((function($__4) {
      var $__6;
      var $__5 = $traceurRuntime.assertObject($__4),
          mode = $__5.mode,
          source = $__5.source;
      switch (mode) {
        case TOKEN_TAG:
          ($__6 = game).addTag.apply($__6, $traceurRuntime.spread(parseTag(source)));
          break;
        case TOKEN_PLY_NOTATION:
          game.move(source);
          break;
        case TOKEN_ANNOTATION_NOTATION:
          game.annotate(source);
          break;
        case TOKEN_RESULT:
          game.finish(source);
          break;
      }
    }));
  } catch (err) {
    if (err instanceof ChessError) {
      err.lastPosition = FEN.stringify(last(game.ply).position);
    }
    throw err;
  }
  return game;
}
function parseTag(line) {
  var $__4 = $traceurRuntime.assertObject(line.split(/\s+/)),
      key = $__4[0],
      value = $__4[1];
  return [key, cleanValue(value)];
}
function cleanValue(value) {
  return value.replace(/^[\"\']|[\"\']$/g, '');
}
function tokenizePGN(transcript) {
  var tokens = [];
  var mode = null;
  var lastMode = null;
  var buffer = [];
  var halfmoveToggle = false;
  var skipping = 0;
  transcript.split('').forEach((function(char, i) {
    if (i < skipping) {
      return;
    }
    switch (char) {
      case '[':
      case '{':
        skip(1);
        lastMode = mode;
        finishToken();
        mode = char == '[' ? TOKEN_TAG : TOKEN_ANNOTATION_NOTATION;
        break;
      case '}':
      case ']':
        finishToken();
        mode = lastMode;
        lastMode = null;
        return;
      case ' ':
      case '.':
        if (mode === TOKEN_PLY_NOTATION) {
          if (buffer.length == 0) {
            return;
          }
          finishToken();
          if (halfmove()) {
            mode = TOKEN_PLY_NOTATION;
          }
          return;
        }
        if (mode === TOKEN_MOVE_NUMBER_NOTATION) {
          if ('.' === char) {
            buffer.push(char);
          }
          finishToken();
          mode = TOKEN_PLY_NOTATION;
          return;
        }
        break;
      default:
        if (!/\d/.test(char)) {
          break;
        }
        if (mode === null || mode === TOKEN_PLY_NOTATION) {
          var p3 = peek(3),
              p7 = peek(7);
          if (p3 === '1-0' || p3 === '0-1') {
            result(p3);
            skip(3);
            return;
          }
          if (p7 === '1/2-1/2') {
            result(p7);
            skip(7);
            return;
          }
        }
        if (mode === null) {
          mode = TOKEN_MOVE_NUMBER_NOTATION;
        }
    }
    if (mode !== null && skipping < i) {
      buffer.push(char);
    }
    function skip(n) {
      skipping = i + n - 1;
    }
    function peek(n) {
      var str = '';
      for (var j = 0; j < n; j++) {
        str += transcript[$traceurRuntime.toProperty(i + j)];
      }
      return str;
    }
  }));
  return tokens;
  function halfmove() {
    return halfmoveToggle = !halfmoveToggle;
  }
  function result(source) {
    tokens.push({
      mode: TOKEN_RESULT,
      source: source
    });
    mode = null;
    buffer = [];
  }
  function finishToken() {
    if (mode == null) {
      return;
    }
    if (buffer.length > 0) {
      try {
        throw undefined;
      } catch (source) {
        {
          source = buffer.join('');
          tokens.push({
            mode: mode,
            source: source
          });
        }
      }
    }
    mode = null;
    buffer = [];
  }
}
